## MAIN FUNCTIONS ####################################################

##' @title Simulate a genome object
##' @param nmark vector of integers of length nchrom giving the
##' count of measured markers on each chromosome, if named it is
##' assumed the names correspond to the chromosomes, otherwise
##' chromosomes are simply numbered
##' @param markerFun list of functions to simulate marker measurements
##' by chromosome, recycled if it is not as long as nmark
##' @param locFuns list of functions that generate locations for
##' markers by chromosome, recycled if it is not as long as nmark
##' @param alleles vector of possible allele annotations, if missing
##' this is taken to be c("A","a") for every marker site
##' @return a genome object
##' @author Chris Salahub
simGenome <- function(nmark, alleles, markerFuns = markerHybrid,
                      locFuns = locationRegular) {
    ## check marker names and generate a chromosome indicator
    if (is.null(names(nmark))) {
        chr <- factor(rep(1:length(nmark), each = nmark))
    } else {
        chr <- factor(rep(names(nmark), each = nmark),
                      levels = names(nmark))
    }
    ## generate alleles if necessary
    if (missing(alleles)) alleles <- generateBiAllelic(nmark)
    ## create encodings
    encoding <- generateEncoding(nmark, markerFuns)
    ## create distances
    locations <- generateLocations(nmark, locFuns)
    ## collect into genome object
    genome <- list(encoding = encoding, chromosome = chr,
                   alleles = alleles, location = locations)
    class(genome) <- "genome"
    genome
}

##' @title Filling the encoding of a genome
##' @param location list of marker locations by chromosome
##' @param alleles list of alleles by marker location
##' @param chromosome factor giving chromosome values with levels
##' ordered as they should appear in plots, etc.
##' @param markerFuns list of functions to generate marker
##' observations by chromosome
##' @return a genome object with the given locations with encodings
##' generated by markerFuns
##' @author Chris Salahub
makeGenome <- function(location, alleles, chromosome,
                       markerFuns = markerPureDom) {
    ## check arguments match
    if (!all(sapply(location, length) == table(chromosome))) {
        stop("Locations and chromosomes imply differing structure")
    }
    if (length(alleles) != length(chromosome)) {
        stop("Alleles and chromosomes imply differing structure")
    }
    if (!is.factor(chromosome)) {
        warning("Warning: chromosome is not an ordered factor")
        chromosome <- factor(chromosome, levels = unique(chromosome))
    }
    ## generate encoding based on marker functions
    encoding <- generateEncoding(sapply(location, length), markerFuns)
    structure(list(encoding = encoding, chromosome = chromosome,
                   alleles = alleles, location = location),
              class = "genome")
}

##' @title Subsetting a genome object
##' @param genome object to be subset
##' @param inds indices of markers to be kept
##' @return a genome object containing only the markers at inds
##' @author Chris Salahub
subsetGenome <- function(genome, inds) {
    newchr <- genome$chromosome[inds] # subset chromosomes
    newloc <- split(unlist(genome$location)[inds], newchr)
    structure(list(encoding = genome$encoding[inds,],
                   chromosome = newchr,
                   alleles = genome$alleles[inds],
                   location = newloc),
              class = "genome")
}

##' @title Checking if an object is a valid genome
##' @param genome object to be checked
##' @return TRUE if the object is a genome, otherwise text outlining
##' what failed
##' @author Chris Salahub
checkGenome <- function(genome) {
    isgen <- TRUE # change if false
    ## check names of elements
    if (sort(names(genome)) != c("alleles", "chromosome", "location",
                                 "encoding")) {
        isgen <- FALSE
        cat("Slots namely incorrectly or missing\n")
    } else if (!is.list(genome$alleles) | # check types of elements
               !is.vector(genome$chromosome) |
               !is.list(genome$location) |
               !is.matrix(genome$encoding)) {
        isgen <- FALSE
        cat("Slots contain data of the incorrect type\n")
    } else if (length(genome$alleles) != nrow(genome$encoding)) {
        isgen <- FALSE
        cat("Number of alleles does not match encoding\n")
    } else if (!identical(table(genome$chromosome),
                          sapply(genome$location, length))) {
        isgen <- FALSE
        cat("Locations do not match number of markers by chromosome\n")
    } else if (length(genome$alleles) != length(genome$chromosome)) {
        isgen <- FALSE
        cat("Distances and alleles imply differing counts of markers\n")
    } else if (!is.factor(genome$chromosome)) {
        cat("Chromosome is not an ordered factor\n")
    }
    isgen
}

##' @title Simple encoding functions
##' @param annotation character vector giving observed annotations
##' @param alleles character vector of possible annotations
##' @param values numeric vector of the same length as alleles giving
##' the value of each allele when encoded
##' @return numeric vector of encodings
##' @author Chris Salahub
encode <- function(annotation, alleles, values) {
    names(values) <- alleles
    values[annotation]
}

##' @title Convert a data.frame to a genome object
##' @param df data.frame with columns "mv", "pv", "chr", and "pos"
##' @param alleles list with the same length as df that gives the
##' potential alleles for each row
##' @param values list of identical form to alleles giving numeric
##' values for the encoding of each possible allele
##' @param missing string values to be interpreted as missing values
##' @param encoder function which accepts an annotation and its
##' possible values and returns an encoding
##' @return a genome object wit locations given by  pos across
##' chromosomes given by chr with encodings given by the values in mv
##' and pv
##' @author Chris Salahub
asGenome <- function(df, alleles, values = c(1,0),
                     missing = c(".", "-"), encoder = encode) {
    ## safety checks
    stopifnot(all(c("mv", "pv", "chr", "pos") %in% names(df)))
    if (is.list(alleles) & (length(alleles) != nrow(df))) {
        stop("Length of list of alleles must match number of rows in df")
    }
    if (!all(sapply(alleles, length) == sapply(values, length))) {
        stop("Lengths of alleles must match lengths of values")
    }
    ## replace missing values
    df$mv[df$mv %in% missing] <- NA
    df$pv[df$pv %in% missing] <- NA
    ## missing alleles
    if (missing(alleles)) {
        warning("alleles not provided, assuming upper/lower case")
        alleles <- lapply(df$mv,
                          function(an) {
                              c(toupper(an), tolower(an))
                          })
    }
    ## alleles/values not lists: encode all at once
    if (!is.list(alleles)) {
        enc <- matrix(encode(as.matrix(df[, c("mv", "pv")]),
                             alleles, values),
                      nrow = nrow(df))
        ## repeat for final object
        alleles <- rep(list(alleles), length = nrow(df))
        values <- rep(list(values), length = nrow(df))
    } else { # encode line by line
        enc <- sapply(1:nrow(df),
                  function(ii) encoder(df[ii, c("mv", "pv")],
                                       alleles[[ii]], values[[ii]]))
    }
    chrom <- if (is.factor(df$chr)) {
                 df$chr }
             else factor(df$chr, levels = unique(df$chr))
    ## collect into genome object
    genome <- list(encoding = enc,
                   chromosome = chrom,
                   alleles = alleles,
                   location = split(df$pos, df$chr))
    class(genome) <- "genome"
    genome
}
